<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">

    <link rel="stylesheet" href="css/mmaz.css">
    <link rel="stylesheet" href="css/opensans.css">


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css">

    <link rel="stylesheet" href="css/liger_mode.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>

    <script
            src="https://code.jquery.com/jquery-3.6.0.js"
            integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.16.2/cytoscape.min.js"></script>
    <script src="https://cdn.rawgit.com/cpettitt/dagre/v0.7.4/dist/dagre.min.js"></script>
    <script src="https://cdn.rawgit.com/cytoscape/cytoscape.js-dagre/1.5.0/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/popper.js@1.14.7/dist/umd/popper.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-popper@1.0.4/cytoscape-popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@4.0.1/umd/index.all.min.js"></script>
    <script src ="https://codemirror.net/5/addon/mode/simple.js"></script>
</head>

<top>
    <banner>
        <a href="http://www.uni-konstanz.de/" target="_blank">
            <img style="border: 0;" src="images/logo.svg" alt="unilogo" width="160" height="135"
                 title="Uni Konstanz" align="left">
        </a>
    </banner>
    <header>
        <h1>LiGER testpage </h1>
        <h2>
            Written by <a href="index.html" style="text-decoration:none;color:white;"> Mark-Matthias Zymla</a> <br>
        </h2>
    </header>
</top>
<container>
    <nav>
        <ul>
            <li><a href="#abstract_syntax_annotator"> Introduction </a></li>
            <li><a href="#simple_demo"> Demo description </a></li>
            <li><a href="#demo_form"> The demo </a></li>
            <li><a href="#semantics_demo">Glue semantics</a></li>
        </ul>
    </nav>

    <article>

        <h1 id="abstract_syntax_annotator">
            LiGER (Linguistic Graph Expansion and Rewriting)
        </h1>

        <p>
            In line with much recent research on semantic annotation, LiGER is designed to
            add annotations to syntactic analyses of natural language expressions. In particular, the system focuses
            on analyses provided by two syntactic frameworks, namely, LFG (as implemented in the Xerox Lingustics
            Environment (XLE)), and Universal Dependencies (as implemented in the Stanford CoreNLP library).
        </p>
        <p>
            The system translates (parts) of LFG and UD representations into more abstract linguistic annotation graphs
            and allows the user to apply transfer rules (an expression coined by the XLE transfer system) to rewrite
            and expand on linguistic annotations. The system is inspired by the previously mentioned transfer component
            of the XLE, the packed rewrite system, which is, unfortunately not supported by XLE anymore.
            LiGER aims at picking up this legacy and provides a framework independent
            rule system for expansion or rewriting of linguistic annotations.
        </p>
        <p>
            In addition to adding linguistic annotations (i.e., relational information and linguistic feature
            information)
            the system is also coupled with the Glue Semantics Workbench (GSWB), a glue semantics prover written in
            Java.
            To make use of the GSWB, the system also allows users to write rules that directly produce glue semantics
            representations based on a description-by-analysis framework.
        </p>
        <p>
            This page provides a simple demo of the system with a visualization component to better explain the
            capabilities
            of the system, as well as some experimental examples for extended functionalities.
        </p>


        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'general')" id="defaultOpen">General</button>
            <button class="tablinks" onclick="openTab(event, 'argument_annotation')">Argument annotation</button>
            <button class="tablinks" onclick="openTab(event, 'other_interfaces')">Other</button>
        </div>

        <div id="general" class="tabcontent">

            <h2 id="querying">Querying: </h2>


            <p>The rewrite system is based on a query language for directed graphs. The following demo parses a sentence
            with a UD parser and then queries the resulting graph with the presented query.If the graph satisfies the query,
                then the system returns true, else it returns false. </p>

            <form action="#" onsubmit="return false;" id="demo_form4">
                <label for="s2">Input sentence:</label><br>
                <input type="text" id="s5" name="sentence" value="Every man loves a woman."><br>
            </form>

            <label for="s4">Input rule:</label><br>
            <textarea class="query" id="s6" name="sentence">#a POS VBZ</textarea>
            <br>
            <input type="submit" value="Submit"
                   onclick="querySentence('/query','s6','s5','sem4')">

            <sem id="sem4"></sem>


            <h2 id="simple_demo">
                Simple Demo:
            </h2>

            <p>The simple demo adds abstract tense and aspect information to a universal dependency graph. More concretely,
                it aggregates syntactic features into semantically interpretable features. It abstracts away from complex
                syntactic structures
                to a simple attribute/value matrix for tense and aspect. For this purpose it uses the rules listed in
                <a href="test_files/testRulesUD4.txt" target="_blank">TAM-conversion rules</a>. The final result of this
                conversion is given
                in the TAM node. These test rules follow, to some extent, the best practices of encoding tense and aspect in
                XLE
                in accordance with the <a href="https://pargram.w.uib.no/" target="_blank">ParGram project</a>, providing
                a flat analysis of complex auxiliary constructions (e.g. English perfect, and progressive).</p>
            <ul class="a">
                <li>Light blue circles describe the initial syntactic analysis (a UD dependency parse)</li>
                <li>Red circles describe the added annotation</li>
            </ul>

            <form action="#" onsubmit="return false;" id="demo_form">
                <label for="s1">Input sentence:</label><br>
                <input type="text" id="s1" name="sentence" value="John loves Mary."><br>
                <input type="submit" value="Submit" onclick="process_sentence('/annotate','s1','graph_window1','cy')">
            </form>

            <h3 id="graph_window1">
                Graph should appear below here:
            </h3>
            <cy id='cy'></cy>

            <h2 id="semantics_demo">
                Glue semantics integration demo
            </h2>

            <p>
                In addition to adding relational and attribute/value information, the abstract syntax annotator also allows
                users
                to design rules that produce semantic representations. More concretely, the system allows users to add
                meaning
                constructors, semantic representations used in Glue semantics. Rules for semantic interpretation initialize
                a set
                of nodes the indices of which serve the generation of linear logic formulas.
            </p>
            <p>
                The system uses the rules in
                <a href="test_files/testRulesUD1.txt" target="_blank">semantic interpretation rules</a> to produce meaning
                constructors. These rules make use of the fact, that variables on the left hand side can be instantiated to
                concrete values on the right side of a rule (If multiple instantiations are possible, all instantiations are
                produced, but are mapped to different readings of the sentence).
            </p>

            <form action="#" onsubmit="return false;" id="demo_form2">
                <label for="s2">Input sentence:</label><br>
                <input type="text" id="s2" name="sentence" value="Every man loves a woman."><br>
                <input type="submit" value="Submit"
                       onclick="process_sentence('/semantics','s2','graph_window2','cy2','sem1')">
            </form>

            <h3 id="graph_window2">
                Graph should appear below here:
            </h3>

            <cy id='cy2'></cy>
            <sem id="sem1"></sem>

            <h2 id="rules_demo">
                How to write rules
            </h2>

            <p>
                In this section, you can modify the simple TAM rules introduced above. For this, a simple editor is provided.
                The editor highlights variables of different kinds and certain functional elements such as the rule separator,
                the conjunction, and the end-of-rule ".". The "submit" button below the input text provides a syntactic analysis
                provided by the Stanford CoreNLP. The "submit" button below the rule editor is used to apply the rules in the editor
                to the sentence entered above. This demo only allows for feature rewriting, not for semantic analysis. This feature will be added
                soon.
            </p>

            <form action="#" onsubmit="return false;" id="demo_form3">
                <label for="test_sent">Test sentence:</label> <br>
                <input type="text" style="width: 750px;" name="test_sent" id='test_sent' value="Jordan has visited her mother.">
                </input>
            </form>
                <br>
                <input type="submit" value="Submit"
                       onclick="process_sentence('/parse','test_sent','graph_window3','cy3')">
                <br>

                <label for="s4">Input rule:</label><br>
                <editor>
                <textarea class="rule" id="s4" name="sentence"></textarea>
                </editor>
            <br>
            <input type="submit" value="Submit"
                   onclick="annotateFromEditor(rule_editor,'test_sent','graph_window3','cy3')">



            <h3 id="graph_window3">
                Graph should appear below here:
            </h3>

            <cy id='cy3'></cy>


        </div>


        <div id="argument_annotation" class="tabcontent">

            <h2 id="annotate_args">Argument annotation: </h2>
            <form action="#" onsubmit="return false;" id="demo_form10">
                <label>Premise:</label><br>
                <input type="text" id="s101" name="sentence" value="Researchers believe that Covid has a high mortality rate."><br>
            </form>

            <form action="#" onsubmit="return false;" id="demo_form11">
                <label>Conclusion:</label><br>
                <input type="text" id="s102" name="sentence" value="Allegedly, Covid is dangerous."><br>
            </form>

            <form action="#" onsubmit="return false;" id="demo_form12">
                <label for="relation">Test sentences:</label> <br>
                <select name="relation" id='relation'>
                    <option value="support">support</option>
                    <option value="attack">attack</option>
                    <option value="rephrase">rephrase</option>
                </select>
            </form>

            <input type="submit" value="Submit"
                   onclick="annotateArguments('s101','s102','relation' ,'res101')">

            <argument id="res101"></argument>

            <h2 id="querying2">Querying multiple arguments: </h2>

            <input type="submit" value="Submit"
                   onclick="queryArgList('sem45')">

            <argument id="sem45"></argument>
        </div>

<!--
        <div id="other_interfaces" class="tabcontent">

            <h1>
                GKR interface
            </h1>
            <label for="s4">Input sentence:</label><br>
            <textarea class="rule" id="s7" name="sentence">Peter doubts that Mary loves Jordan.</textarea>
            <br>

            <label for="s4">Input context:</label><br>
            <textarea class="rule" id="s8">""</textarea>
            <br>
            <input type="submit" value="Submit"
                   onclick="annotateGKRSentence('s7','s8')">
        </div>
-->



        <!--
        <h2 id="treebank_demo"></h2>
        <wrapper>
            <wrapper style="float: left">
                <select id="treebank_list" name="treebank" class="treebank" size="10">
                    <option value="item1">Item 1
                    <option value="item2">Item 2
                    <option value="item3">Item 3
                </select><br>
                <input type="submit" value="Load treebank" onclick="console.log('Pressed a button')"
                       style="width: 200px;
                   font-family: Open Sans;
                   font-size: 14px;
	               font-style: normal;
	               font-variant: normal;
	               font-weight: 400;
                   height: 50px;
                   border-color: #00a9e0;
                   color: #00a9e0">
            </wrapper>
            <wrapper style="float: left">
                <cy id='cy4'></cy>
                <sem id="sem3"></sem>
            </wrapper>
        </wrapper>
-->

        <script>
            //Address of the controller on server side







            //   var input = "";

            //To add tool tips to elements (used to add avps to graphs)
            function makePopper(ele) {
                let ref = ele.popperRef(); // used only for positioning

                ele.tippy = tippy(ref, { // tippy options:
                    content: () => {
                        let content = document.createElement('div');

                        var attributes = ele._private.data;
                        console.log(attributes);

                        if (attributes.hasOwnProperty("avp")) {
                            for (var key in attributes.avp) {
                                content.innerHTML = content.innerHTML + key + " : " + attributes.avp[key] + "<br>";
                            }
                        }

                        //content.innerHTML = ele.id();

                        return content;
                    },
                    trigger: 'manual' // probably want manual mode
                });
            }

           // var page = "https://staging.liger.sperrle.dbvis.de"
            var page = "http://localhost:8080";

            //Reads in sentence and formats it for a request to server
            function process_sentence(controller, input_id, graph_window, graph_container, sem_container) {
                var sentence = document.getElementById(input_id).value;
                document.getElementById(graph_window).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)

                var params = {in: sentence}
                console.log("Generated parameter: " + params);

                var url = page + controller + formatParams(params);
                console.log("Make post request to: " + url);

                //Does the method need a callback to use this?
                $.ajax({
                    url: url,
                    dataType: 'json',
                    type: 'post',
                    success: function (data) {
                        //alert( "SUCCESS:  " + data);
                        var input = data;
                        console.log(data);
                        if (input.hasOwnProperty("graphElements")) {
                            console.log(input.graphElements);
                        }
                        createGraph(input, graph_container);

                        if (input.hasOwnProperty("semantics") && sem_container != null) {
                            writeToContainer(input.semantics, sem_container);
                        }

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);
                    }
                });
            }

            function annotateSentence(controller, inputId, sentenceWindow, graphWindow, graphContainer, semContainer) {

                editor.save();

                var sentence = document.getElementById(sentenceWindow).value;
                var ruleString = document.getElementById(inputId).value;
                document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)


                $.ajax({
                    url: page + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("graphElements")) {
                            console.log(data.graphElements);
                        }
                        createGraph(data, graphContainer);

                        if (data.hasOwnProperty("semantics") && semContainer != null) {
                            writeToContainer(data.semantics, semContainer);
                        }


                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }


            function annotateFromEditor(editor, sentenceWindow, graphWindow, graphContainer, semContainer) {

                editor.save();

                var sentence = document.getElementById(sentenceWindow).value;
                var ruleString = editor.getValue();
                document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)


                $.ajax({
                    url: page + "/apply_rule",
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("graphElements")) {
                            console.log(data.graphElements);
                        }
                        createGraph(data, graphContainer);

                        if (data.hasOwnProperty("semantics") && semContainer != null) {
                            writeToContainer(data.semantics, semContainer);
                        }


                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }




            function annotateGKRSentence(sentenceID, contextID)
            {
                var sentence = document.getElementById(sentenceID).value;
                var context = document.getElementById(contextID).value;

                console.log(sentence);
                console.log(context);

                var result;

                $.ajax({
                   // url: "https://liger.sperrle.dbvis.de/annotate_gkr",
                     url: "http://localhost:8080/annotate_gkr",
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    //dataType: 'application/json',
                    cache: false,
                    data: JSON.stringify({sentence: sentence, context: ""}),
                    success: function(data) {

                        console.log('success');
                        console.log(data);

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });

            }


            function querySentence(controller, inputId, sentenceWindow, resultContainer) {
                var sentence = document.getElementById(sentenceWindow).value;
                var ruleString = document.getElementById(inputId).value;
                // document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)
                console.log("Read in query:" + ruleString)


                $.ajax({
                    url: page + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("success")) {
                            console.log(data.success);
                        }

                        if (data.hasOwnProperty("success") && resultContainer != null) {
                            writeToContainer(data.success, resultContainer);
                        }


                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);
                        console.log(page+controller + JSON.stringify({sentence: sentence, ruleString: ruleString}));

                    }
                });
            }


            function queryArgList(resultContainer) {
                const controller = "/query_args";

                const premise1 = "This is a first premise.";
                const conclusion1 = "This is a conclusion.";
                const id1 = "arg1";
                const arg1Json = {premise: premise1, conclusion: conclusion1, relation: "support"};

                const premise2 = "This was a second premise.";
                const conclusion2 = "This was a conclusion.";
                const arg_id2 = "arg2";
                const arg2Json = {premise: premise2, conclusion: conclusion2, relation: "support"};


                const premise3 = "This is a third premise.";
                const conclusion3 = "This is a conclusion.";
                const id3 = "arg3";
                const arg3Json = {premise: premise3, conclusion: conclusion3, relation: "support"};

                const query = "#a POS VBZ";

                const id2argMap = {id1: arg1Json, arg_id2: arg2Json, id3: arg3Json}

                const dataInput = JSON.stringify({mpg_arguments: id2argMap, query: query});

                console.log(dataInput);

                $.ajax({
                    url: page + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: dataInput,
                    success: function (data) {
                            writeToContainer(JSON.stringify(data,undefined,2), resultContainer);
                        }
                    ,
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }



            function annotateArguments(inputPrem,inputConcl,inputRelation,resultContainer) {
                var controller = "/annotate_argument"
                var premise = document.getElementById(inputPrem).value;
                var conclusion = document.getElementById(inputConcl).value;
                var relation = document.getElementById(inputRelation).value;
                // document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in premise: " + premise);
                console.log("Read in conclusion: " + conclusion);
                console.log("Read in relation: " + relation);


                $.ajax({
                    url: page + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({premise: premise, conclusion: conclusion, relation: relation}),
                    success: function (data) {

                        if (data.hasOwnProperty("liger_argument")) {
                            console.log('success')
                            console.log(data);
                            writeToContainer(JSON.stringify(data,undefined,2), resultContainer);
                        }
                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }


            function writeToContainer(semantics, container) {
                var container = document.getElementById(container);
                container.innerHTML = "<pre>"+semantics +"</pre>";
            }

            //Makes a request to server to process input sentence. server returns a graph in json form
            //The graph is embedded in a cytoscape graph visualization and displayed on the page.
            function createGraph(input, container) {

                var cy = window[container] = cytoscape({

                    container: document.getElementById(container), // container to render in

                    elements: input.graphElements,
                    style: [ // the stylesheet for the graph
                        {
                            selector: 'node[node_type="input"]',
                            css: {
                                "content": "data(id)",
                                "color": "blue",
                                "text-valign": "center",
                                "text-halign": "center",
                                "height": "60px",
                                "width": "60px",
                                "background-fill": "linear-gradient",
                                "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                                "background-gradient-stop-positions": "0 30 60"
                            }
                        },
                        {
                            selector: 'node[node_type="annotation"]',
                            css: {
                                "content": "data(id)",
                                "color": "blue",
                                "text-valign": "center",
                                "text-halign": "center",
                                "height": "60px",
                                "width": "60px",
                                "background-fill": "linear-gradient",
                                "background-gradient-stop-colors": "red white", // get data from data.color in each node
                                "background-gradient-stop-positions": "0 30 60"
                            }
                        },
                        {
                            selector: 'edge[edge_type="edge"]',
                            style: {
                                'width': 3,
                                'line-color': '#ccc',
                                'target-arrow-color': '#ccc',
                                'target-arrow-shape': 'triangle',
                                'curve-style': 'bezier',

                            }
                        },
                        {
                            selector: 'edge[edge_type="proj"]',
                            style: {
                                'width': 3,
                                'line-color': '#ccc',
                                'line-style': 'dashed',
                                'target-arrow-color': '#ccc',
                                'target-arrow-shape': 'triangle',
                                'curve-style': 'bezier',

                            }
                        },
                        {
                            selector: "edge[label]",
                            css: {
                                "label": "data(label)",
                                "text-rotation": "autorotate",
                                "text-margin-x": "15px",
                                "text-margin-y": "0px"
                            }
                        }
                    ],

                    layout: {
                        name: 'dagre'
                        //  rows: 1
                    }

                });

                /*
                cy.on('tap', 'node', function(evt){
                    var node = evt.target
                    console.log( 'tapped ' + node.id() );
                });
                cy.on('mouseover', 'node', function(event) {
                    var node = event.target;
                    let popper1 = node.popper({
                        content: () => {
                            let div = document.createElement('div');
                            div.innerHTML = 'Popper content';
                            document.body.appendChild(div);
                            return div;
                        },
                        popper: {}
                    });
                });
                */


                //Add tooltips to graph on mouseover
                cy.ready(function () {
                    cy.elements().forEach(function (ele) {
                        //  console.log(ele);
                        //  console.log(ele._private.data);
                        if (ele._private.data.hasOwnProperty("avp")) {
                            makePopper(ele);

                            ele.bind('mouseover', (event) => event.target.tippy.show());

                            //       cy.elements().unbind('mouseout');
                            ele.bind('mouseout', (event) => event.target.tippy.hide());

                        }
                    });
                });


                //      console.log("Read in: " + input);
                //     console.log("From: " + url);
            }


            //Formats input json into a string that can be appended to a server request as parameter
            function formatParams(params) {
                return "?" + Object
                    .keys(params)
                    .map(function (key) {
                        return key + "=" + encodeURIComponent(params[key])
                    })
                    .join("&")
            }

            function openTab(evt, tabName) {
                var i, tabcontent, tablinks;

                // Hide all tab content
                tabcontent = document.getElementsByClassName("tabcontent");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }

                // Deactivate all tab links
                tablinks = document.getElementsByClassName("tablinks");
                for (i = 0; i < tablinks.length; i++) {
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }

                // Show the selected tab content
                document.getElementById(tabName).style.display = "block";

                // Activate the selected tab link
                evt.currentTarget.className += " active";
            }

            // Set the default tab to be open
            document.getElementById("defaultOpen").click();

            //Container for displaying the graph produced by callREST()
        </script>
    </article>
</container>

<script>




    CodeMirror.defineMode("liger", function() {
        return {
            token: function(stream,state) {
                if (stream.match("==>") ) {
                    return "rule_separator";
                }

                else if (stream.match(/#[A-Za-z0-9]+/))
                {
                    return "liger_node_var";
                }

                else if (stream.match(/%[A-Za-z0-9]+/)) {
                    return "liger_val_var";
                }
                else if (stream.match(/(\&|\.)/)) {

                    return "liger_conjunction";
                } else if (stream.match("//")) {
                    stream.skipToEnd();
                    return "comment"; // Use the "comment" CSS class for the comment token
                }
                else {
                    stream.next();
                    return null;
                }
            }

        };
    });


    var rule_editor = CodeMirror.fromTextArea(document.getElementById("s4"), {
        mode: "liger"
    });

    var url = page + "/test_files/testRulesUD4b.txt";

    var rules = "--replace(true);\n" +
        "\n" +
        "//Finite forms\n" +
        "#a POS VBZ & #a TOKEN %a ==> #a MORPH #b & #b FIN '+' & #b FORM 'pres' & #b HEAD %a.\n" +
        "#a POS VBP & #a TOKEN %a ==> #a MORPH #b & #b FIN '+' & #b FORM 'pres' & #b HEAD %a.\n" +
        "#a POS VBD & #a TOKEN %a ==> #a MORPH #b & #b FIN '+' & #b FORM 'past' & #b HEAD %a.\n" +
        "#a POS MD & #a TOKEN %a ==> #a MORPH #b & #b FIN '+' & #b FORM 'lex(%a,tense)' & #b HEAD %a.\n" +
        "\n" +
        "\n" +
        "//Non-finite forms\n" +
        "#a POS VBG & #a TOKEN %a ==> #a MORPH #b & #b FIN '-' & #b HEAD %a & #b FORM 'prpart'.\n" +
        "#a POS VBN & #a TOKEN %a ==> #a MORPH #b & #b FIN '-' & #b HEAD %a & #b FORM 'ppart'.\n" +
        "#a POS VB & #a TOKEN %a ==> #a MORPH #b & #b FIN '-' & #b HEAD %a & #b FORM 'inf'.\n" +
        "\n" +
        "//Copu\n" +
        "#a POS JJ & #a TOKEN %a & #a cop #b TOKEN %b &\n" +
        "#b MORPH #c FIN %c & #c FORM %d ==> #a MORPH #c & #c HEAD %b %a & #c FIN %c & #c FORM %d.\n" +
        "\n" +
        "\n" +
        "//separate finite from non-finite verbs\n" +
        "#a MORPH #b FIN '+' ==> #b AUX '-'.\n" +
        "\n" +
        "#a FORM 'ppart' ==> #a ASPECT 'perf'.\n" +
        "#a FORM 'prpart' ==> #a ASPECT 'prog'.\n" +
        "\n" +
        "#a aux #b & #b MORPH #c ASPECT %c & #a MORPH #d &\n" +
        "#c HEAD %b & #d HEAD %d\n" +
        "==> #c AUX '+' & #d ASP-AUX #c & #d MAIN '+' & #d HEAD %b %d.\n" +
        "\n" +
        "#a cop #b & #b TOKEN %c & #b MORPH #c ASPECT %c &\n" +
        "#c HEAD %b & #a TOKEN %a\n" +
        "==> #c AUX '+' & #d ASP-AUX #c & #d MAIN '+' & #c HEAD %b %a.\n" +
        "\n" +
        "//Fusing heads for aux verbs in the main verb (finite aux)\n" +
        "#a aux #b & #b MORPH #c FORM 'inf' & #a MORPH #d &\n" +
        "#c HEAD %b & #d HEAD %d\n" +
        "==> #c AUX '+' & #d ASP-AUX #c & #d MAIN '+' & #d HEAD %b %d.\n" +
        "\n" +
        "#a aux:pass #b & #b MORPH #c FORM 'inf' & #a MORPH #d &\n" +
        "#c HEAD %b & #d HEAD %d\n" +
        "==> #c AUX '+' & #d ASP-AUX #c & #d MAIN '+' & #d HEAD %b %d.\n" +
        "\n" +
        "#a aux #b & #b MORPH #c FIN '+' & #c FORM %c & #a MORPH #d &\n" +
        "#c HEAD %b & #d HEAD %d\n" +
        "==> #c AUX '+' & #d AUX #c & #d MAIN '+' & #d FIN '+' & #d FORM %c & #d HEAD %b %d.\n" +
        "\n" +
        "//#a aux:pass #b & #a MORPH #c FIN '+' & #b MORPH #d &\n" +
        "//#c HEAD %b & #d HEAD %d\n" +
        "//==> #b AUX '+' & #c AUX #d & #c MAIN '+' & #c HEAD %d %b.\n" +
        "\n" +
        "//#a aux:pass #b & #a MORPH #c FIN '-' & #b MORPH #d &\n" +
        "//#c HEAD %b & #d HEAD %d\n" +
        "//==> #b AUX '+' & #c AUX #d & #c MAIN '+' & #c HEAD %d %b.\n" +
        "\n" +
        "#a aux:pass #b & #a MORPH #c & #b MORPH #d &\n" +
        "#c HEAD %b & #d HEAD %d & #d FIN %a\n" +
        "==> #d AUX '+' & #c AUX #d & #c MAIN '+' & #c FIN %a & #c HEAD %d %b.\n" +
        "\n" +
        "//#a aux #b & #b MORPH #c TENSE %c & #a MORPH #d FORM 'ppart' ==> #c AUX '+' & #d AUX #c & #d MAIN '+' & #d ASPECT 'perf' & #b ASPECT 'perf'.\n" +
        "//#a aux #b & #b MORPH #c TENSE %c & #a MORPH #d FORM 'prpart' ==> #c AUX '+' & #d AUX #c & #d MAIN '+' & #d ASPECT 'prog'.\n" +
        "\n" +
        "#a LEMMA go & #a MORPH #b ASPECT 'prog' &\n" +
        "#a aux #c MORPH #f FIN '+' & #f FORM %f &\n" +
        "#a xcomp #d & #d MORPH #e &\n" +
        "#b HEAD %b & #e HEAD %e\n" +
        "==> #e AUX #b & #e FORM %f('fut') & #b MAIN '-' & #e FIN '+' & #b FIN '+' & #e MAIN '+' & #e HEAD %b to %e.\n" +
        "\n" +
        "//Simple tense\n" +
        "#b FIN '+' & #b FORM %b & #b HEAD %c & #b AUX '-' ==> #b TAM #d & #d HEAD '%c' & #d TENSE %b & #d FIN '+'.\n" +
        "\n" +
        "//Tense from aux verb\n" +
        "#b MAIN '+' & #b AUX #c & #c FIN '+' & #b FORM %b &\n" +
        "#c HEAD %d & #b HEAD %c ==> #c TAM #d & #b TAM #d & #d HEAD '%c' & #d TENSE %b & #d FIN '+'.\n" +
        "\n" +
        "//non-finite\n" +
        "#a HEAD %a & #a FIN '-' & #a MAIN '+' ==> #a TAM #b & #b HEAD '%a'.\n" +
        "\n" +
        "//aspect\n" +
        "#a HEAD %a & #a MAIN '+' & #a ASPECT %b & #a FIN '-' & #a TAM #b ==> #b ASPECT %b.\n" +
        "\n" +
        "//Aspect\n" +
        "#a TAM #b & #a MAIN '+' & #a ASPECT %a & #a FIN '+' ==> #b ASPECT %a.\n" +
        "#a TAM #b & #a MAIN '+' & #a ASPECT %a & #a ASP-AUX #c ASPECT %b ==> #b ASPECT '%b,%a'.\n" +
        "\n" +
        "\n";

    /*
    fetch(url).then(response => response.text())
        .then((data) => {
            rules = data;
        })

     */
    rule_editor.getDoc().setValue(rules);







</script>

</html>
<!--
    //  var sentence = prompt("Enter a sentence");
    /*
        var params =  {
            in: sentence
        }
        const url =  page + formatParams(params)
        console.log(url);
    */
    /*
      $.getJSON(url, { get_param: 'value' }, function(data) {
          $.each(data, function(index, element) {
              $('body').append($('<div>', {
                  text: element.in
              }));
          });
      });
  */
    /*
    fetch(url)
    .then(res => res.json())
    .then((out) => {
        console.log("Output: ", out);
    }).catch(err => console.error(err));
*/
    // const xhr = new XMLHttpRequest();
    /*
       xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE)
        {
         alert(xhr.response);
        } else
        {
            alert(xhr.response);
            console.log("Failed ready state" + xhr.readyState);
            alert("Request failed");
        }
        }
    */
    /*
    xhr.responseType = 'json';
    xhr.open("GET",url,true);
    xhr.onload = function() {
        var jsonResponse = xhr.response;
        console.log("This is the content of the file:" + jsonResponse.content);
    };
    xhr.send(null);
*/
    /*
    xhr.onload = function() {
        var status = xhr.status;
        if (status === 200) {
            alert(xhr.response);
        }else{
            alert(status);
        }
    };
     */
    //   xhr.send();
    //  document.write(http.responseText)
    /*
    $.getJSON("cyto.js", function (data) {
        console.log(data);
        console.log("This is a test.");
        var cy = window.cy = cytoscape({
            container: document.getElementById('cy'),
            elements: data,
            style: [ // the stylesheet for the graph
                {
                    selector: 'node[type="syntax"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'node[type="semantics"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "red white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'edge[type="edge"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: 'edge[type="proj"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'line-style': 'dashed',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: "edge[label]",
                    css: {
                        "label": "data(label)",
                        "text-rotation": "autorotate",
                        "text-margin-x": "0px",
                        "text-margin-y": "-15px"
                    }
                }
            ],
            layout: {
                name: 'breadthfirst'
                //  rows: 1
            }
        });
    });
*/
    /*
        var cy = window.cy = cytoscape({
            container: document.getElementById('cy'), // container to render in
            elements: input,
            style: [ // the stylesheet for the graph
                {
                    selector: 'node[type="syntax"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'node[type="semantics"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "red white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'edge[type="edge"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: 'edge[type="proj"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'line-style': 'dashed',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: "edge[label]",
                    css: {
                        "label": "data(label)",
                        "text-rotation": "autorotate",
                        "text-margin-x": "0px",
                        "text-margin-y": "-15px"
                    }
                }
            ],
            layout: {
                name: 'breadthfirst'
                //  rows: 1
            }
        });
    */
    /*
    var cy = window.cy = cytoscape({
        container: document.getElementById('cy'), // container to render in
        elements: [ // list of graph elements to start with
            { // node a
                data: {id: '1',type: "syntax"}
            },
            { // node b
                data: {id: '2',type: "syntax"}
            },
            {
                data: {id: '3',type: "syntax"}
            },
            { // edge ab
                data: {id: '12', source: '1', target: '2', label: "TENSE",type: "edge" }
            },
            { // edge ab
                data: {id: '13', source: '1', target: '3', label: "ASPECT",type: "edge"}
            },
            { // node a
                data: {id: '4',type: "semantics"}
            },
            { // node b
                data: {id: '5',type: "semantics"}
            },
            {
                data: {id: '6',type: "semantics"}
            },
            { // edge ab
                data: {id: '45', source: '4', target: '5', label: "TENSE",type: "edge"}
            },
            { // edge ab
                data: {id: '46', source: '4', target: '6', label: "ASPECT",type: "edge"}
            },
            { // edge ab
                data: {id: '14', source: '1', target: '4', label: "projection",type: "proj"}
            }
        ]
        ,
        style: [ // the stylesheet for the graph
            {
                selector: 'node[type="syntax"]',
                css: {
                    "content": "data(id)",
                    "color": "blue",
                    "text-valign": "center",
                    "text-halign": "center",
                    "height": "60px",
                    "width": "60px",
                    "background-fill": "linear-gradient",
                    "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                    "background-gradient-stop-positions": "0 30 60"
                }
            },
            {
                selector: 'node[type="semantics"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "red white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
            },
            {
                selector: 'edge[type="edge"]',
                style: {
                    'width': 3,
                    'line-color': '#ccc',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                }
            },
            {
                selector: 'edge[type="proj"]',
                style: {
                    'width': 3,
                    'line-color': '#ccc',
                    'line-style': 'dashed',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                }
            },
            {
                selector: "edge[label]",
                css: {
                    "label": "data(label)",
                    "text-rotation": "autorotate",
                    "text-margin-x": "0px",
                    "text-margin-y": "-15px"
                }
            }
        ],
        layout: {
            name: 'breadthfirst'
         //  rows: 1
        }
    });
     */
-->