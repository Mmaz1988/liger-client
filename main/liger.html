<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">

    <link rel="stylesheet" href="css/mmaz.css">
    <link rel="stylesheet" href="css/opensans.css">


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css">

    <link rel="stylesheet" href="css/liger_mode.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>

    <script
            src="https://code.jquery.com/jquery-3.6.0.js"
            integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.16.2/cytoscape.min.js"></script>
    <script src="https://cdn.rawgit.com/cpettitt/dagre/v0.7.4/dist/dagre.min.js"></script>
    <script src="https://cdn.rawgit.com/cytoscape/cytoscape.js-dagre/1.5.0/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/popper.js@1.14.7/dist/umd/popper.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-popper@1.0.4/cytoscape-popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@4.0.1/umd/index.all.min.js"></script>
    <script src ="https://codemirror.net/5/addon/mode/simple.js"></script>
</head>

<top>
    <banner>
        <a href="http://www.uni-konstanz.de/" target="_blank">
            <img style="border: 0;" src="images/logo.svg" alt="unilogo" width="160" height="135"
                 title="Uni Konstanz" align="left">
        </a>
    </banner>
    <header>
        <h1>LiGER testpage </h1>
        <h2>
            Written by <a href="index.html" style="text-decoration:none;color:white;"> Mark-Matthias Zymla</a> <br>
        </h2>
    </header>
</top>
<container>
    <nav>
        <ul>
            <li><a href="#abstract_syntax_annotator"> Introduction </a></li>
            <li><a href="#simple_demo"> Demo description </a></li>
            <li><a href="#demo_form"> The demo </a></li>
            <li><a href="#semantics_demo">Glue semantics</a></li>
        </ul>
    </nav>

    <article>

        <h1 id="abstract_syntax_annotator">
            LiGER (Linguistic Graph Expansion and Rewriting)
        </h1>

        <p>
            In line with much recent research on semantic annotation, LiGER is designed to
            add annotations to syntactic analyses of natural language expressions. In particular, the system focuses
            on analyses provided by two syntactic frameworks, namely, LFG (as implemented in the Xerox Lingustics
            Environment (XLE)), and Universal Dependencies (as implemented in the Stanford CoreNLP library).
        </p>
        <p>
            The system translates (parts) of LFG and UD representations into more abstract linguistic annotation graphs
            and allows the user to apply transfer rules (an expression coined by the XLE transfer system) to rewrite
            and expand on linguistic annotations. The system is inspired by the previously mentioned transfer component
            of the XLE, the packed rewrite system, which is, unfortunately not supported by XLE anymore.
            LiGER aims at picking up this legacy and provides a framework independent
            rule system for expansion or rewriting of linguistic annotations.
        </p>
        <p>
            In addition to adding linguistic annotations (i.e., relational information and linguistic feature
            information)
            the system is also coupled with the Glue Semantics Workbench (GSWB), a glue semantics prover written in
            Java.
            To make use of the GSWB, the system also allows users to write rules that directly produce glue semantics
            representations based on a description-by-analysis framework.
        </p>
        <p>
            This page provides a simple demo of the system with a visualization component to better explain the
            capabilities
            of the system, as well as some experimental examples for extended functionalities.
        </p>


        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'general')" id="defaultOpen">General</button>
            <button class="tablinks" onclick="openTab(event, 'argument_annotation')">Argument annotation</button>
            <button class="tablinks" onclick="openTab(event, 'other_interfaces')">Other</button>
        </div>

        <div id="general" class="tabcontent">

            <h2 id="querying">Querying: </h2>


            <p>The rewrite system is based on a query language for directed graphs. The following demo parses a sentence
            with a UD parser and then queries the resulting graph with the presented query.If the graph satisfies the query,
                then the system returns true, else it returns false. </p>

            <form action="#" onsubmit="return false;" id="demo_form4">
                <label for="s2">Input sentence:</label><br>
                <input type="text" id="s5" name="sentence" value="Every man loves a woman."><br>
            </form>

            <label for="s4">Input rule:</label><br>
            <textarea class="query" id="s6" name="sentence">#a POS VBZ</textarea>
            <br>
            <input type="submit" value="Submit"
                   onclick="querySentence('/query','s6','s5','sem4')">

            <sem id="sem4"></sem>


            <h2 id="simple_demo">
                Simple Demo:
            </h2>

            <p>The simple demo adds abstract tense and aspect information to a universal dependency graph. More concretely,
                it aggregates syntactic features into semantically interpretable features. It abstracts away from complex
                syntactic structures
                to a simple attribute/value matrix for tense and aspect. For this purpose it uses the rules listed in
                <a href="test_files/testRulesUD4.txt" target="_blank">TAM-conversion rules</a>. The final result of this
                conversion is given
                in the TAM node. These test rules follow, to some extent, the best practices of encoding tense and aspect in
                XLE
                in accordance with the <a href="https://pargram.w.uib.no/" target="_blank">ParGram project</a>, providing
                a flat analysis of complex auxiliary constructions (e.g. English perfect, and progressive).</p>
            <ul class="a">
                <li>Light blue circles describe the initial syntactic analysis (a UD dependency parse)</li>
                <li>Red circles describe the added annotation</li>
            </ul>

            <form action="#" onsubmit="return false;" id="demo_form">
                <label for="s1">Input sentence:</label><br>
                <input type="text" id="s1" name="sentence" value="John loves Mary."><br>
                <input type="submit" value="Submit" onclick="process_sentence('/annotate','s1','graph_window1','cy')">
            </form>

            <h3 id="graph_window1">
                Graph should appear below here:
            </h3>
            <cy id='cy'></cy>

            <h2 id="semantics_demo">
                Glue semantics integration demo
            </h2>

            <p>
                In addition to adding relational and attribute/value information, the abstract syntax annotator also allows
                users
                to design rules that produce semantic representations. More concretely, the system allows users to add
                meaning
                constructors, semantic representations used in Glue semantics. Rules for semantic interpretation initialize
                a set
                of nodes the indices of which serve the generation of linear logic formulas.
            </p>
            <p>
                The system uses the rules in
                <a href="test_files/testRulesUD1.txt" target="_blank">semantic interpretation rules</a> to produce meaning
                constructors. These rules make use of the fact, that variables on the left hand side can be instantiated to
                concrete values on the right side of a rule (If multiple instantiations are possible, all instantiations are
                produced, but are mapped to different readings of the sentence).
            </p>

            <form action="#" onsubmit="return false;" id="demo_form2">
                <label for="s2">Input sentence:</label><br>
                <input type="text" id="s2" name="sentence" value="Every man loves a woman."><br>
                <input type="submit" value="Submit"
                       onclick="process_sentence('/semantics','s2','graph_window2','cy2','sem1')">
            </form>

            <h3 id="graph_window2">
                Graph should appear below here:
            </h3>

            <cy id='cy2'></cy>
            <sem id="sem1"></sem>

            <h2 id="rules_demo">
                How to write rules
            </h2>

            <p>
                In this section, you can modify the simple semantic rules introduced above. For this, a simple editor is provided.
                The editor highlights variables of different kinds and certain functional elements such as the rule separator,
                the conjunction, and the end-of-rule ".". The "Parse input" button below the input text provides a syntactic analysis
                provided by the Stanford CoreNLP. The "Apply rules" button below the rule editor is used to apply the rules in the editor
                to the sentence entered above.
                </p>

            <p>
                After submitting the rules, the system displays those rules that apply to the current input in the order that they apply.
                Each rule is accompanied by a "rule" button. Clicking this button allows the user to show how the graph has been rewritten at that
                particular point. This functionality serves to debug rewrite rules.
            </p>

            <p>
            Below the graph window, the semantics are displayed. Below that, the meaning constructors leading to the semantic computation are listed.
            </p>

            <div style="display: flex; flex-wrap: wrap;">
                <div style="flex: 1;">
            <form action="#" onsubmit="return false;" id="demo_form3">
                <label for="test_sent">Test sentence:</label> <br>
                <input type="text" style="width: 750px;" name="test_sent" id='test_sent' value="Every man loves a woman.">
              </form>
                <br>
                <input type="submit" value="Parse input sentence"
                       onclick="process_sentence('/parse','test_sent','graph_window3','cy3')">
                <br>

                <label for="s4">Input rules:</label><br>
                <editor>
                <textarea class="rule" id="s4" name="sentence"></textarea>
                </editor>
            <br>
            <input type="submit" value="Apply rules"
                   onclick="annotateFromEditor(rule_editor,'test_sent','graph_window3','cy3','sem5', 'glueEditor')">
                    <br>

                    <ul id="rule_list"  style="width: 800px; border: 2px solid #00a9e0; margin: 5px;">

                    </ul>

                </div>
            <div style="flex: 1;">



            <h3 id="graph_window3">
                Graph should appear below here:
            </h3>

            <cy id='cy3'></cy>


                <h3>
                    Meaning constructors:
                </h3>
                <editor>
                    <textarea class="rule" id="glueEditor" name="sentence"></textarea>
                </editor>

                <form id="gswbPreferencesForm">
                    <div>
                        <label for="prover">Prover:</label>
                        <select id="prover" name="prover">
                            <option value="0">Hepple</option>
                            <option value="1">Lev</option>
                        </select>
                    </div>

                    <div>
                        <label for="outputstyle">Output Style:</label>
                        <select id="outputstyle" name="outputstyle">
                            <option value="0">Plain</option>
                            <option value="1">Prolog</option>
                            <option value="3">NLTK</option>
                        </select>
                    </div>

                    <div>
                        <label for="parseSem">
                            <input type="checkbox" id="parseSem" name="parseSem">
                            Parse Semantics
                        </label>
                    </div>

                    <div>
                        <label for="explain">
                            <input type="checkbox" id="explain" name="explain">
                            Explanation
                        </label>
                    </div>

                    <div>
                        <label for="debugging">
                            <input type="checkbox" id="debugging" name="debugging">
                            Debugging
                        </label>
                    </div>

                    <input type="submit" value="Submit">
                </form>

                <h3> Semantics: </h3>
                <sem id="sem5"></sem>
                <h3>Log:</h3>
                <log id="log1"></log>
            </div>


            </div>
        </div>


        <div id="argument_annotation" class="tabcontent">

            <h2 id="annotate_args">Argument annotation: </h2>
            <form action="#" onsubmit="return false;" id="demo_form10">
                <label>Premise:</label><br>
                <input type="text" id="s101" name="sentence" value="Researchers believe that Covid has a high mortality rate."><br>
            </form>

            <form action="#" onsubmit="return false;" id="demo_form11">
                <label>Conclusion:</label><br>
                <input type="text" id="s102" name="sentence" value="Allegedly, Covid is dangerous."><br>
            </form>

            <form action="#" onsubmit="return false;" id="demo_form12">
                <label for="relation">Test sentences:</label> <br>
                <select name="relation" id='relation'>
                    <option value="support">support</option>
                    <option value="attack">attack</option>
                    <option value="rephrase">rephrase</option>
                </select>
            </form>

            <input type="submit" value="Submit"
                   onclick="annotateArguments('s101','s102','relation' ,'res101')">

            <argument id="res101"></argument>

            <h2 id="querying2">Querying multiple arguments: </h2>

            <input type="submit" value="Submit"
                   onclick="queryArgList('sem45')">

            <argument id="sem45"></argument>
        </div>

<!--
        <div id="other_interfaces" class="tabcontent">

            <h1>
                GKR interface
            </h1>
            <label for="s4">Input sentence:</label><br>
            <textarea class="rule" id="s7" name="sentence">Peter doubts that Mary loves Jordan.</textarea>
            <br>

            <label for="s4">Input context:</label><br>
            <textarea class="rule" id="s8">""</textarea>
            <br>
            <input type="submit" value="Submit"
                   onclick="annotateGKRSentence('s7','s8')">
        </div>
-->



        <!--
        <h2 id="treebank_demo"></h2>
        <wrapper>
            <wrapper style="float: left">
                <select id="treebank_list" name="treebank" class="treebank" size="10">
                    <option value="item1">Item 1
                    <option value="item2">Item 2
                    <option value="item3">Item 3
                </select><br>
                <input type="submit" value="Load treebank" onclick="console.log('Pressed a button')"
                       style="width: 200px;
                   font-family: Open Sans;
                   font-size: 14px;
	               font-style: normal;
	               font-variant: normal;
	               font-weight: 400;
                   height: 50px;
                   border-color: #00a9e0;
                   color: #00a9e0">
            </wrapper>
            <wrapper style="float: left">
                <cy id='cy4'></cy>
                <sem id="sem3"></sem>
            </wrapper>
        </wrapper>
-->

        <script>
            //Address of the controller on server side







            //   var input = "";

            //To add tool tips to elements (used to add avps to graphs)
            function makePopper(ele) {
                let ref = ele.popperRef(); // used only for positioning

                ele.tippy = tippy(ref, { // tippy options:
                    content: () => {
                        let content = document.createElement('div');

                        var attributes = ele._private.data;
                        console.log(attributes);

                        if (attributes.hasOwnProperty("avp")) {
                            for (var key in attributes.avp) {
                                content.innerHTML = content.innerHTML + key + " : " + attributes.avp[key] + "<br>";
                            }
                        }

                        //content.innerHTML = ele.id();

                        return content;
                    },
                    trigger: 'manual' // probably want manual mode
                });
            }

            function getGswbPreferencesJSON() {
                var prover = parseInt(document.getElementById("prover").value);
                var outputstyle = parseInt(document.getElementById("outputstyle").value);
                var parseSem = document.getElementById("parseSem").checked;
                var explain = document.getElementById("explain").checked;
                var debugging = document.getElementById("debugging").checked;
        //        var explainFail = document.getElementById("explainFail").checked;

                var jsonObject = {
                    "prover": prover,
                    "outputstyle": outputstyle,
                    "parseSem": parseSem,
                    "noreduce": false,
                    "glueOnly": false,
                    "meaningOnly": false,
                    "explainFail": explain,
                    "debugging": debugging
                };

                return jsonObject;
            }

            document.getElementById("gswbPreferencesForm").addEventListener("submit", function(event) {
                event.preventDefault();
                var gswbPreferencesJSON = getGswbPreferencesJSON();
                console.log(gswbPreferencesJSON);
                var mcsString = glue_editor.getDoc().getValue();

                var GswbRequest = {
                    "premises": mcsString,
                    "gswbPreferences": gswbPreferencesJSON
                }

                gswbDeduce(JSON.stringify(GswbRequest), "sem5", "log1");
            });

            // var page = "https://staging.liger.sperrle.dbvis.de"
            var ligerpage = "http://localhost:8080";
            var gswbpage = "http://localhost:8081"

            function gswbDeduce(gswbRequest, semContainer, logContainer)
            {
                $.ajax({
                    url: gswbpage + "/deduce",
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: gswbRequest,
                    success: function (data) {
                        //alert( "SUCCESS:  " + data);

                        console.log(data);

                        //write each solution to html element with id semContainer as string per line
                        var semContainerElement = document.getElementById(semContainer);

                        if (data.hasOwnProperty("solutions"))
                        {
                            semContainerElement.innerHTML = "";
                            for (var i = 0; i < data["solutions"].length; i++) {
                                semContainerElement.innerHTML += data["solutions"][i] + "<br>";
                            }
                        }

                        if (data.hasOwnProperty("derivation"))
                        {
                            var logContainerElement = document.getElementById(logContainer);

                            logContainerElement.innerText = data["derivation"];
                        }

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);
                    }
                });

            }





            //Reads in sentence and formats it for a request to server
            function process_sentence(controller, input_id, graph_window, graph_container, sem_container) {
                var sentence = document.getElementById(input_id).value;
                document.getElementById(graph_window).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)

                var params = {in: sentence}
                console.log("Generated parameter: " + params);

                var url = ligerpage + controller + formatParams(params);
                console.log("Make post request to: " + url);

                //Does the method need a callback to use this?
                $.ajax({
                    url: url,
                    dataType: 'json',
                    type: 'post',
                    success: function (data) {
                        //alert( "SUCCESS:  " + data);
                        var input = data;
                        console.log(data);
                        if (input.hasOwnProperty("graphElements")) {
                            console.log(input.graphElements);
                        }
                        createGraph(input, graph_container);

                        if (input.hasOwnProperty("semantics") && sem_container != null) {
                            writeToContainer(input.semantics, sem_container);
                        }

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);
                    }
                });
            }

            function annotateSentence(controller, inputId, sentenceWindow, graphWindow, graphContainer, semContainer) {

                editor.save();

                var sentence = document.getElementById(sentenceWindow).value;
                var ruleString = document.getElementById(inputId).value;
                document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)


                $.ajax({
                    url: ligerpage + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("graphElements")) {
                            console.log(data.graphElements);
                        }
                        createGraph(data, graphContainer);

                        if (data.hasOwnProperty("semantics") && semContainer != null) {
                            writeToContainer(data.semantics, semContainer);
                        }


                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }


            function annotateFromEditor(editor, sentenceWindow, graphWindow, graphContainer, semContainer, editContainer) {


                document.getElementById("rule_list").innerHTML = "";
                editor.save();

                console.log(graphContainer);

                var sentence = document.getElementById(sentenceWindow).value;
                var ruleString = editor.getValue();
                document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)


                $.ajax({
                    url: ligerpage + "/apply_rule_xle_test",
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("graph")) {
                            if (data.graph.hasOwnProperty("graphElements")) {
                                console.log(data.graph.graphElements);
                            }
                        }
                        createGraph(data.graph, graphContainer);

                        console.log(graphContainer);

                        if (data.hasOwnProperty("appliedRules"))
                        {
                            var ruleList = document.getElementById("rule_list");

                            for (let i = 0; i < data.appliedRules.length; i++)
                            {
                               // <button onClick="myFunction()">Click me</button>
                                const ligerID = "'lr" + i + "'";
                                const sentID = "'" + sentenceWindow + "'";
                                const graphID = "'" + graphWindow + "'";
                                const gcID =  "'" + graphContainer + "'";
                                const semID = "'" + semContainer + "'";
                                const editID = "'" + editContainer+ "'";

                                const onclickFunction = 'annotateFromAppliedRules(' + ligerID + ',' + sentID + ',' + graphID + ',' +
                                    gcID + ',' + semID + ',' + editID + ')';

                                console.log(onclickFunction);

                                const divContainerString = ' <div style="display: flex; flex-wrap: wrap; ' +
                                                                         'column-gap: 20px; ' +
                                                                         'padding: 5px;' +
                                                                         'border: 2px solid #00a9e0;' +
                                                                         'align-items: flex-start;">';
                                const divString =  '<div style="flex: 0 auto;">';

                                ruleList.innerHTML += ('<li>' +
                                    divContainerString +
                                    divString +
                                    '<button onClick="' + onclickFunction + '"' +
                                    ' id=' + ligerID +
                                    'style="color: white; background-color: #00a9e0; border-color: white;"' +
                                    '>' +
                                    'Rule ' + i + ':' + '</button>' +
                                    '</div>' +
                                    '<div id=' + 'lrdiv' + i +
                                    ' style="flex: 0 auto;"' +
                                    '>' +
                                     htmlEscape(data.appliedRules[i]) +
                                    '</div>' +
                                    '</div>' +
                                    '</li>');
                            }
                        }

                        /*
                        if (data.graph.hasOwnProperty("semantics") && semContainer != null) {
                            writeToContainer(data.graph.semantics, semContainer);
                        }

                         */

                        if (data.hasOwnProperty("meaningConstructors") && editContainer != null)
                        {
                                glue_editor.getDoc().setValue(data.meaningConstructors);
                        }

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }


            function htmlEscape(text) {
                // Replace all occurrences of "<" with "&lt;"
                text = text.replace(/</g, "&lt;");
                // Replace all occurrences of ">" with "&gt;"
                text = text.replace(/>/g, "&gt;");
                return text;
            }



            function annotateFromAppliedRules(ruleID, sentenceWindow, graphWindow, graphContainer, semContainer, editCont) {

                console.log("successfully called annotateFromAppliedRules");
                console.log(ruleID);
                console.log(sentenceWindow);
                console.log(graphWindow);
                console.log(graphContainer);
        //        console.log(semContainer);

             //   document.getElementById("rule_list").innerHTML = "";
             //   editor.save();

                var sentence = document.getElementById(sentenceWindow).value;

                var listPosition = ruleID.match(/\d+$/);

                var ruleString = "--replace(true);\n";

                for (let i = 0; i <= listPosition; i++)
                {
                    var listEntry = document.getElementById("lrdiv" + i);
                    ruleString += listEntry.innerText + '\n';
                }

                console.log(ruleString);

                document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)


                $.ajax({
                    url: ligerpage + "/apply_rule_xle_test",
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("graph")) {
                            if (data.graph.hasOwnProperty("graphElements")) {
                                console.log(data.graph.graphElements);
                            }
                        }
                        createGraph(data.graph, graphContainer);

                        /*
                        if (data.hasOwnProperty("appliedRules"))
                        {
                            var ruleList = document.getElementById("rule_list");

                            for (let i = 0; i < data.appliedRules.length; i++)
                            {
                                // <button onClick="myFunction()">Click me</button>

                                ruleList.innerHTML += ('<li>' + '<button onClick="" id="lr"' + i + '>' +
                                    data.appliedRules[i] + '</button>' + '</li>');
                            }
                        }



                        if (data.graph.hasOwnProperty("semantics") && semContainer != null) {
                            writeToContainer(data.graph.semantics, semContainer);
                        }
                         */

                        if (data.hasOwnProperty("meaningConstructors") && editCont != null)
                        {
                            glue_editor.getDoc().setValue(data.meaningConstructors);
                        }

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }




            function annotateGKRSentence(sentenceID, contextID)
            {
                var sentence = document.getElementById(sentenceID).value;
                var context = document.getElementById(contextID).value;

                console.log(sentence);
                console.log(context);

                var result;

                $.ajax({
                   // url: "https://liger.sperrle.dbvis.de/annotate_gkr",
                     url: "http://localhost:8080/annotate_gkr",
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    //dataType: 'application/json',
                    cache: false,
                    data: JSON.stringify({sentence: sentence, context: ""}),
                    success: function(data) {

                        console.log('success');
                        console.log(data);

                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });

            }


            function querySentence(controller, inputId, sentenceWindow, resultContainer) {
                var sentence = document.getElementById(sentenceWindow).value;
                var ruleString = document.getElementById(inputId).value;
                // document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in sentence:" + sentence)
                console.log("Read in query:" + ruleString)


                $.ajax({
                    url: ligerpage + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({sentence: sentence, ruleString: ruleString}),
                    success: function (data) {

                        if (data.hasOwnProperty("success")) {
                            console.log(data.success);
                        }

                        if (data.hasOwnProperty("success") && resultContainer != null) {
                            writeToContainer(data.success, resultContainer);
                        }


                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);
                        console.log(ligerpage+controller + JSON.stringify({sentence: sentence, ruleString: ruleString}));

                    }
                });
            }


            function queryArgList(resultContainer) {
                const controller = "/query_args";

                const premise1 = "This is a first premise.";
                const conclusion1 = "This is a conclusion.";
                const id1 = "arg1";
                const arg1Json = {premise: premise1, conclusion: conclusion1, relation: "support"};

                const premise2 = "This was a second premise.";
                const conclusion2 = "This was a conclusion.";
                const arg_id2 = "arg2";
                const arg2Json = {premise: premise2, conclusion: conclusion2, relation: "support"};


                const premise3 = "This is a third premise.";
                const conclusion3 = "This is a conclusion.";
                const id3 = "arg3";
                const arg3Json = {premise: premise3, conclusion: conclusion3, relation: "support"};

                const query = "#a POS VBZ";

                const id2argMap = {id1: arg1Json, arg_id2: arg2Json, id3: arg3Json}

                const dataInput = JSON.stringify({mpg_arguments: id2argMap, query: query});

                console.log(dataInput);

                $.ajax({
                    url: ligerpage + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: dataInput,
                    success: function (data) {
                            writeToContainer(JSON.stringify(data,undefined,2), resultContainer);
                        }
                    ,
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }



            function annotateArguments(inputPrem,inputConcl,inputRelation,resultContainer) {
                var controller = "/annotate_argument"
                var premise = document.getElementById(inputPrem).value;
                var conclusion = document.getElementById(inputConcl).value;
                var relation = document.getElementById(inputRelation).value;
                // document.getElementById(graphWindow).innerHTML = 'Now displaying graph for "' + sentence + '"';
                console.log("Read in premise: " + premise);
                console.log("Read in conclusion: " + conclusion);
                console.log("Read in relation: " + relation);


                $.ajax({
                    url: ligerpage + controller,
                    contentType: "application/json; charset=utf-8",
                    type: 'POST',
                    // async: false,
                    cache: false,
                    data: JSON.stringify({premise: premise, conclusion: conclusion, relation: relation}),
                    success: function (data) {

                        if (data.hasOwnProperty("liger_argument")) {
                            console.log('success')
                            console.log(data);
                            writeToContainer(JSON.stringify(data,undefined,2), resultContainer);
                        }
                    },
                    error: function (data) {
                        alert("ERROR:  " + data);
                        console.log(data);

                    }
                });
            }


            function writeToContainer(semantics, container) {
                var container = document.getElementById(container);
                container.innerHTML = "<pre>"+semantics +"</pre>";
            }

            //Makes a request to server to process input sentence. server returns a graph in json form
            //The graph is embedded in a cytoscape graph visualization and displayed on the page.
            function createGraph(input, container) {

                console.log(input);
                console.log(container);

                var cy = window[container] = cytoscape({

                    container: document.getElementById(container), // container to render in

                    elements: input.graphElements,
                    style: [ // the stylesheet for the graph
                        {
                            selector: 'node[node_type="input"]',
                            css: {
                                "content": "data(id)",
                                "color": "blue",
                                "text-valign": "center",
                                "text-halign": "center",
                                "height": "60px",
                                "width": "60px",
                                "background-fill": "linear-gradient",
                                "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                                "background-gradient-stop-positions": "0 30 60"
                            }
                        },
                        {
                            selector: 'node[node_type="annotation"]',
                            css: {
                                "content": "data(id)",
                                "color": "blue",
                                "text-valign": "center",
                                "text-halign": "center",
                                "height": "60px",
                                "width": "60px",
                                "background-fill": "linear-gradient",
                                "background-gradient-stop-colors": "red white", // get data from data.color in each node
                                "background-gradient-stop-positions": "0 30 60"
                            }
                        },
                        {
                            selector: 'edge[edge_type="edge"]',
                            style: {
                                'width': 3,
                                'line-color': '#ccc',
                                'target-arrow-color': '#ccc',
                                'target-arrow-shape': 'triangle',
                                'curve-style': 'bezier',

                            }
                        },
                        {
                            selector: 'edge[edge_type="proj"]',
                            style: {
                                'width': 3,
                                'line-color': '#ccc',
                                'line-style': 'dashed',
                                'target-arrow-color': '#ccc',
                                'target-arrow-shape': 'triangle',
                                'curve-style': 'bezier',

                            }
                        },
                        {
                            selector: "edge[label]",
                            css: {
                                "label": "data(label)",
                                "text-rotation": "autorotate",
                                "text-margin-x": "15px",
                                "text-margin-y": "0px"
                            }
                        }
                    ],

                    layout: {
                        name: 'dagre'
                        //  rows: 1
                    }

                });

                /*
                cy.on('tap', 'node', function(evt){
                    var node = evt.target
                    console.log( 'tapped ' + node.id() );
                });
                cy.on('mouseover', 'node', function(event) {
                    var node = event.target;
                    let popper1 = node.popper({
                        content: () => {
                            let div = document.createElement('div');
                            div.innerHTML = 'Popper content';
                            document.body.appendChild(div);
                            return div;
                        },
                        popper: {}
                    });
                });
                */


                //Add tooltips to graph on mouseover
                cy.ready(function () {
                    cy.elements().forEach(function (ele) {
                        //  console.log(ele);
                        //  console.log(ele._private.data);
                        if (ele._private.data.hasOwnProperty("avp")) {
                            makePopper(ele);

                            ele.bind('mouseover', (event) => event.target.tippy.show());

                            //       cy.elements().unbind('mouseout');
                            ele.bind('mouseout', (event) => event.target.tippy.hide());

                        }
                    });
                });


                //      console.log("Read in: " + input);
                //     console.log("From: " + url);
            }


            //Formats input json into a string that can be appended to a server request as parameter
            function formatParams(params) {
                return "?" + Object
                    .keys(params)
                    .map(function (key) {
                        return key + "=" + encodeURIComponent(params[key])
                    })
                    .join("&")
            }

            function openTab(evt, tabName) {
                var i, tabcontent, tablinks;

                // Hide all tab content
                tabcontent = document.getElementsByClassName("tabcontent");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }

                // Deactivate all tab links
                tablinks = document.getElementsByClassName("tablinks");
                for (i = 0; i < tablinks.length; i++) {
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }

                // Show the selected tab content
                document.getElementById(tabName).style.display = "block";

                // Activate the selected tab link
                evt.currentTarget.className += " active";
            }

            // Set the default tab to be open
            document.getElementById("defaultOpen").click();

            //Container for displaying the graph produced by callREST()
        </script>
    </article>
</container>

<script>




    CodeMirror.defineMode("liger", function() {
        return {
            token: function(stream,state) {
                if (stream.match("==>") ) {
                    return "rule_separator";
                }

                else if (stream.match(/#[A-Za-z0-9]+/))
                {
                    return "liger_node_var";
                }

                else if (stream.match(/%[A-Za-z0-9]+/)) {
                    return "liger_val_var";
                }
                else if (stream.match(/(\&|\.)/)) {

                    return "liger_conjunction";
                } else if (stream.match("//")) {
                    stream.skipToEnd();
                    return "comment"; // Use the "comment" CSS class for the comment token
                }
                else {
                    stream.next();
                    return null;
                }
            }

        };
    });

    CodeMirror.defineMode("glue", function() {
        return {
            token: function(stream,state) {
                if (stream.match(":") ) {
                    return "rule_separator";
                }

                else if (stream.match(/-o/))
                {
                    return "liger_node_var";
                }

                else if (stream.match(/(\[|\])/)) {
                    return "liger_conjunction";

                }
                else if (stream.match(/(\(|\))/)) {
                    return "liger_val_var";

                }
                else if (stream.match(/(<|>)/)) {
                    return "angular_brackets";

                }
                else if (stream.match("//")) {
                    stream.skipToEnd();
                    return "comment"; // Use the "comment" CSS class for the comment token
                }
                else {
                    stream.next();
                    return null;
                }
            }

        };
    });


    var rule_editor = CodeMirror.fromTextArea(document.getElementById("s4"), {
        mode: "liger"
    });

    var glue_editor = CodeMirror.fromTextArea(document.getElementById("glueEditor"), {
        mode: "glue"
    });

    var rules = "--replace(true);\n" +
        "\n" +
        "#a TNS-ASP #b ==> #a SEM #c & #c TEMP-REF #d & #d T-REF 'undefined' & #c SIT #s.\n" +
        "#a PTYPE 'sem' ==> #a SEM #b & #b SIT #s.\n" +
        "\n" +
        "//Tier 1 rules\n" +
        "#a TNS-ASP #b TENSE 'past' & #a SEM #c TEMP-REF #d & #d T-REF 'undefined' ==>  #d T-REF 'past' & #d CHECK '-'.\n" +
        "#a TNS-ASP #b TENSE 'pres' & #a SEM #c TEMP-REF #d & #d T-REF 'undefined' ==>  #d T-REF 'pres' & #d CHECK '-'.\n" +
        "#a TNS-ASP #b TENSE 'fut' & #a SEM #c TEMP-REF #d & #d T-REF 'undefined' ==>  #d T-REF 'fut' & #d CHECK '-'.\n" +
        "\n" +
        "//#a TNS-ASP #b TENSE 'pres' & #a SEM #c ==> #c TEMP-REF #d & #d T-REF 'pres' & #d EVAL #e & #e TIME 'now'.\n" +
        "//#a TNS-ASP #b TENSE 'fut' & #a SEM #c ==> #c TEMP-REF #d & #d T-REF 'fut' & #d EVAL #e & #e TIME 'now'.\n" +
        "\n" +
        "//Tier 2 rules\n" +
        "//SOT rule\n" +
        "#a T-REF 'past' &\n" +
        "#a CHECK '-' &\n" +
        "#a ^(TEMP-REF>SEM>COMP) #b & #b !(SEM>TEMP-REF) #c T-REF 'past' ==> #a T-REF 'non-future' & #a CHECK '+' & #a EVAL #c.\n" +
        "\n" +
        "//Present counterfactual\n" +
        "#a T-REF 'past' &\n" +
        "#a CHECK '-' &\n" +
        "#a ^(TEMP-REF>SEM>OBJ>in_set>ADJUNCT) #b & #b VTYPE 'modal' &\n" +
        "#b !(SEM>TEMP-REF) #c T-REF 'pres' &\n" +
        "#c CHECK '-'\n" +
        "==> #a T-REF 'non-past' & #c CHECK '+' & #c EVAL #a.\n" +
        "\n" +
        "\n" +
        "//Relative tense rules\n" +
        "#a T-REF 'undefined' &\n" +
        "#a ^(TEMP-REF>SEM>XCOMP) #b & #b !(SEM>TEMP-REF) #c ==> #a EVAL #c.\n" +
        "\n" +
        "#a T-REF %a & %a != 'undefined' & #a CHECK '-' ==> #a EVAL #b.\n" +
        "\n" +
        "//Aspect rules\n" +
        "#a TNS-ASP #b PROG '+_' & #a SEM #c ==> #c VIEWPOINT #d & #d ASPECT 'impv' & #d A-RESTR 'ongoing'.\n" +
        "#a TNS-ASP #b PROG '-_' & #a SEM #c ==> #c VIEWPOINT #d & #d ASPECT 'undefined'.\n" +
        "#a TNS-ASP #b TENSE %x & #b PROG '-_' & #a SEM #c VIEWPOINT #d ASPECT 'undefined' ==> #d ASPECT 'prv' & #d A-RESTR 'bounded'.\n" +
        "#a TNS-ASP #b PERF '+_' & #a SEM #c ==> #c ASP-TENSE #d & #d A-REF 'past'.\n" +
        "\n" +
        "//Tier 2 aspect example\n" +
        "#a T-REF 'undefined' &\n" +
        "#a ^(TEMP-REF) #b ^(SEM>XCOMP) #c & #c !(SEM>TEMP-REF) #d EVAL #e &\n" +
        "#b VIEWPOINT #f ASPECT 'prv'\n" +
        "==>  #a T-REF 'future' & #a EVAL #d.\n" +
        "\n" +
        "//undefined FPS for transitive verbs\n" +
        "#a TNS-ASP #b & #a PRED %a & #a SEM #z  ==>\n" +
        "#z FPS #y & #y CHECK '+'.\n" +
        "\n" +
        "#a TNS-ASP #b & #a PRED %a & #a SEM #z & #a SUBJ #c & #a OBJ #d & strip(%a) == 'push' &\n" +
        "#z FPS #e & #e CHECK '+' ==>\n" +
        "#e CHECK '-' &\n" +
        "#e initP #f &\n" +
        "#f INIT #a &\n" +
        "#f I-SUBJ #c &\n" +
        "#e procP #g &\n" +
        "#g PROC #a &\n" +
        "#g P-SUBJ #d &\n" +
        "#e XP #h &\n" +
        "#h REF 'unspec' &\n" +
        "#h TYPE 'rheme'.\n" +
        "\n" +
        "#a TNS-ASP #b & #a PRED %a & #a SEM #z & #a SUBJ #c & #a OBJ #d & strip(%a) == 'bake' &\n" +
        "#z FPS #e & #e CHECK '+' ==>\n" +
        "#e CHECK '-' &\n" +
        "#e initP #f &\n" +
        "#f INIT #a &\n" +
        "#f I-SUBJ #c &\n" +
        "#e procP #g &\n" +
        "#g PROC #a &\n" +
        "#g P-SUBJ #c &\n" +
        "#e XP #h &\n" +
        "#h REF 'unspec' &\n" +
        "#h TYPE 'rheme'.\n" +
        "\n" +
        "#a TNS-ASP #b & #a PRED %a & #a SEM #z & #a SUBJ #c & #a OBJ #d & #a OBJ-TH #e & strip(%a) == 'give' &\n" +
        "#f FPS #g & #g CHECK '+' ==>\n" +
        "#g CHECK '-' &\n" +
        "#g initP #i &\n" +
        "#i INIT #a &\n" +
        "#i I-SUBJ #c &\n" +
        "#g procP #j &\n" +
        "#j PROC #a &\n" +
        "#j P-SUBJ 'undefined' &\n" +
        "#g resP #k &\n" +
        "#k RES #a &\n" +
        "#k R-SUBJ #d &\n" +
        "#g XP #l &\n" +
        "#l REF #e &\n" +
        "#l TYPE 'possession'.\n" +
        "\n" +
        "//Semantic interpretation\n" +
        "\n" +
        "//Semantic interpretation\n" +
        "//attributes without values can be used for existential constraints\n" +
        "#g NTYPE & #g PRED %g\n" +
        "==> #g SEM #i & #i GLUE strip(%g) : #i.\n" +
        "\n" +
        "//NP Quantifier -- Sem structure\n" +
        "#g ^(SPEC) #h & #g QUANT #i & #h SEM #l ==> #l VAR #j & #l RESTR #k & #l SIT #s.\n" +
        "#g ^(SPEC) #h & #g DET #i & #h SEM #l ==> #l VAR #j & #l RESTR #k & #l SIT #s.\n" +
        "\n" +
        "//relative clause (with who)\n" +
        "#a PRED %a & #a PRON-REL #b & #a SUBJ #b &\n" +
        "#a SEM #z & #b SEM #y &\n" +
        "#a ^(in_set>ADJUNCT) #c SEM #d VAR #e & #d RESTR #f & #d SIT #s\n" +
        "==> #y GLUE [/P_<e,t>.[/Q_<e,t>.[/x_e.(P(x) \\& Q(x))]]] : ((#e -o #f) -o ((#y -o #z) -o (#e -o #f))).\n" +
        "\n" +
        "//NP Quantifier instantiation\n" +
        "\n" +
        "//Universal quantifier\n" +
        "#g ^(SPEC) #h SEM #i VAR #j & #i RESTR #k & #i SIT #s &\n" +
        "#g QUANT #l PRED %l & %l == 'every' &\n" +
        "#h ^(%) #m SEM #n FPS #b & #n SIT #o\n" +
        "==> #i GLUE [/P_<e,<s,t>>.[/Q_<e,<s,t>>.[/s_s.Ax_e[P(x)(s) -> Q(x)(s)]]]] : ((#j -o (#s -o #k)) -o ((#i -o (#o -o #n)) -o (#o -o #n))).\n" +
        "\n" +
        "//Existential quantifier\n" +
        "#g ^(SPEC) #h SEM #i VAR #j & #i RESTR #k & #i SIT #s &\n" +
        "#g DET #l PRED %l & %l == 'a' &\n" +
        "#h ^(%) #m SEM #n FPS #b & #n SIT #o\n" +
        "==> #i GLUE [/P_<e,<s,t>>.[/Q_<e,<s,t>>.[/s_s.Ex_e[P(x)(s) \\& Q(x)(s)]]]] : ((#j -o (#s -o #k)) -o ((#i -o (#o -o #n)) -o (#o -o #n))).\n" +
        "\n" +
        "\n" +
        "#g ^(SPEC) #h SEM #i VAR #j & #i RESTR #k & #i SIT #s &\n" +
        "#g DET #l DET-TYPE 'def'\n" +
        "==> #i GLUE [/P_<e,<s,t>>.Ix_e[P(x)]] : ((#j -o (#s -o #k)) -o #i).\n" +
        "\n" +
        "//==> #i SIT #s & #i GLUE [/P_<e,<s,t>>.[/Q_<e,<s,t>>.[/s_s.the(P(x)(s),Q(x)(s))]]] : ((#j -o (#s -o #k)) -o ((#i -o (#o -o #n)) -o (#o -o #n))).\n" +
        "\n" +
        "\n" +
        "//predicates for Quantifiers\n" +
        "#g SEM #j VAR #i & #j RESTR #k & #j SIT #a & #g PRED %g ==> #a GLUE [/x_e.[/s_s.strip(%g)(x,s)]] : (#i -o (#a -o #k)).\n" +
        "\n" +
        "\n" +
        "//modification\n" +
        "#g SEM #j VAR #i & #j RESTR #k & #j SIT #l &\n" +
        "#g ADJUNCT #e in_set #h OBJ #m SEM #a  & #h SEM #b SIT #c\n" +
        "==> #h GLUE [/P_<e,<s,t>>.[/Q_<e,<s,t>>.[/x_e.[/s_s.(P(x)(s) \\& Q(x)(s))]]]] : ((#j -o (#c -o #b)) -o ((#i -o (#l -o #k)) -o (#i -o (#l -o #k)))) &\n" +
        " #e GLUE [/y_e.[/x_e.[/s_s.with(x,y,s)]]] : (#a -o (#j -o (#c -o #b))).\n" +
        "\n" +
        "//FPS rules\n" +
        "\n" +
        "#a SEM #z FPS #y CHECK '+' & #a PRED %a ==> #y EVENT #x & #x GLUE [/e_v.strip(%a)(e)] : (#x -o #y).\n" +
        "\n" +
        "#a XP #b REF 'unspec' & #b TYPE 'rheme' ==> #b GLUE y : #b.\n" +
        "\n" +
        "\n" +
        "//RES\n" +
        "#a XP #b &\n" +
        "#b REF #c &\n" +
        "#b TYPE 'possession' &\n" +
        "#a resP #d &\n" +
        "#d RES #e &\n" +
        "#d R-SUBJ #f ==>\n" +
        "#b GLUE [/x_e.[/y_e.[/e_v.(have(e) \\& (ag(e,x) \\& th(e,y)))]]] : (#f -o (#c -o (#e -o #b))) &\n" +
        "#d GLUE [/P_<e,<v,t>>.[/x_e.[/e_v.(res(e,x) \\& P(x)(e))]]] : ((#f -o (#e -o #b)) -o (#f -o (#e -o #d))).\n" +
        "\n" +
        "//PROC\n" +
        "#d SEM #z FPS #b procP #c PROC #d & #c P-SUBJ 'undefined' &\n" +
        "#b resP #g RES #d &\n" +
        "#b XP #f TYPE 'possession' & #f REF #j ==>\n" +
        "#c GLUE [/P_<v,t>.[/e_v.Ee1_v[Ee2_v[equals(e,to(e1,e2)) \\& (proc(e1) \\& P(e2))]]]] : ((#d -o #g) -o (#d -o #c)).\n" +
        "\n" +
        "#a SEM #z FPS #b procP #c PROC #d & #c P-SUBJ #e & #b XP #f TYPE 'rheme' ==>\n" +
        "#c GLUE [/y_s.[/x_e.[/e_v.proc(e,x,y)]]] : (#f -o (#e -o (#d -o #c))).\n" +
        "\n" +
        "\n" +
        "\n" +
        "//INIT\n" +
        "#a SEM #z FPS #b initP #c I-SUBJ #d & #c INIT #h & #b procP #e PROC #f ==>\n" +
        "#c GLUE [/P_<v,t>.[/x_e.[/e_v.Ee1_v[Ee2_v[equals(e,to(e1,e2)) \\& (init(e1,x) \\& P(e2))]]]]] : ((#f -o #e) -o (#d -o (#h -o #c))).\n" +
        "\n" +
        "#a SEM #z FPS #b initP #c I-SUBJ #d & #c INIT #h & #b procP #e PROC #f & #e P-SUBJ #d ==>\n" +
        "#c GLUE [/P_<e,<v,t>>.[/x_e.[/e_v.Ee1_v[Ee2_v[equals(e,to(e1,e2)) \\& (init(e1,x) \\& P(x)(e2))]]]]] : ((#d -o (#f -o #e)) -o (#d -o (#h -o #c))).\n" +
        "\n" +
        "\n" +
        "//Subcategorization for verbs\n" +
        "\n" +
        "//Transitive verbs -- Type A\n" +
        "#a SUBJ #b & #a OBJ #c & #a TNS-ASP #d & #a PRED %a &\n" +
        "#a SEM #z FPS #e procP #f P-SUBJ #c SEM #j &\n" +
        "#z SIT #y &\n" +
        "#e initP #h INIT #i & #h I-SUBJ #b SEM #k ==>\n" +
        "#e GLUE [/R_<e,<e,<v,t>>>.[/x_e.[/y_e.[/s_s.[/e_v.(partOf(e,s) \\& (strip(%a)(e) \\& (R(x)(y)(e) \\& (ag(e,x) \\& pt(e,y)))))]]]]] : ((#b -o (#c -o (#i -o #h))) -o (#k -o (#j -o (#y -o (#h -o #e))))).\n" +
        "\n" +
        "//Transitive verbs -- Type B\n" +
        "#a SUBJ #b & #a OBJ #c & #a TNS-ASP #d & #a PRED %a &\n" +
        "#a SEM #z FPS #e procP #f P-SUBJ #b SEM #j &\n" +
        "#z SIT #y &\n" +
        "#e initP #h INIT #i & #h I-SUBJ #b SEM #j &\n" +
        "#c SEM #k\n" +
        "==>\n" +
        "#e GLUE [/R_<e,<v,t>>.[/x_e.[/y_e.[/s_s.[/e_v.(partOf(e,s) \\& (strip(%a)(e) \\& (R(x)(e) \\& (ag(e,x) \\& pt(e,y)))))]]]]] : ((#b -o (#i -o #h)) -o (#j -o (#k -o (#y -o (#h -o #e))))).\n" +
        "\n" +
        "//Ditransitive verb\n" +
        "#a SUBJ #b & #a OBJ #c & #a OBJ-TH #d & #a PRED %a &\n" +
        "#d SEM #h &\n" +
        "#a SEM #z FPS #e resP #f R-SUBJ #c SEM #g &\n" +
        "#z SIT #y &\n" +
        "#e initP #k INIT #l & #k I-SUBJ #b SEM #m ==>\n" +
        "#e GLUE [/R_<e,<e,<e,<v,t>>>>.[/x_e.[/y_e.[/z_e.[/s_s.[/e_v.(partOf(e,s) \\& (strip(%a)(e) \\& (R(x)(y)(z)(e) \\& (ag(e,x) \\& (theme(e,z) \\& goal(e,y))))))]]]]]] : ((#b -o (#c -o (#d -o (#l -o #k)))) -o (#m -o (#g -o (#h -o (#y -o (#k -o #e)))))).\n" +
        "\n" +
        "\n" +
        "//intransitive ohne PFS\n" +
        "#a SUBJ #b SEM #c &\n" +
        "#a SEM #z FPS #f EVENT #y & #f CHECK '+' & #z SIT #x ==>\n" +
        "#f GLUE [/R_<v,t>.[/x_e.[/s_s.[/e_v.(R(e) \\& (partOf(e,s) \\& ag(e,x)))]]]] : ((#y -o #f) -o (#c -o (#x -o (#y -o #f)))).\n" +
        "\n" +
        "//transitive ohne FPS\n" +
        "#a SUBJ #b SEM #c & #a OBJ #d SEM #e &\n" +
        "#a SEM #z FPS #f EVENT #y & #f CHECK '+' & #z SIT #x ==>\n" +
        "#f GLUE [/R_<v,t>.[/x_e.[/y_e.[/s_s.[/e_v.(R(e) \\& (partOf(e,s) \\& (ag(e,x) \\& pt(e,y))))]]]]] : ((#y -o #f) -o (#c -o (#e -o (#x -o (#y -o #f))))).\n" +
        "\n" +
        "\n" +
        "\n" +
        "\n" +
        "//Verb template for comp verbs\n" +
        "#a SUBJ #b SEM #c &\n" +
        "#a SEM #j &\n" +
        "#a COMP #d SEM #e TEMP-REF #f EVAL #g T-REF %i &\n" +
        "#j FPS #h EVENT #i &\n" +
        "#j SIT #k\n" +
        " ==> #h GLUE [/R_<v,t>.[/P_<s,t>.[/x_e.[/s_s.[/e_v.(R(e) \\& (partOf(e,s) \\& (ag(e,x) \\& th(e,P(s)))))]]]]] : ((#i -o #h) -o ((#g -o #e) -o (#c -o (#k -o (#i -o #h))))).\n" +
        "\n" +
        "//XCOMP\n" +
        "//Verb template for comp verbs\n" +
        "#a SUBJ #b SEM #c &\n" +
        "#a SEM #j &\n" +
        "#a XCOMP #d SEM #e TEMP-REF #f EVAL #g T-REF %i &\n" +
        "#j FPS #h EVENT #i &\n" +
        "#j SIT #k\n" +
        " ==> #h GLUE [/R_<v,t>.[/P_<e,<s,t>>.[/x_e.[/s_s.[/e_v.(R(e) \\& (partOf(e,s) \\& (ag(e,x) \\& th(e,P(x)(s)))))]]]]] : ((#i -o #h) -o ((#c -o (#g -o #e)) -o (#c -o (#k -o (#i -o #h))))).\n" +
        "\n" +
        "//Bound-variable (cf) Conditional\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c EVAL #d & #a VTYPE 'modal' &\n" +
        "#a !(ADJUNCT>in_set) #f PRED %a & strip(%a) == 'if' &\n" +
        "#f OBJ #g SEM #h TEMP-REF #i EVAL #j\n" +
        "==> #b COND #k & #k GLUE [/P_<s,t>.[/Q_<s,t>.[/s_s.(P(s) -> Q(s))]]]  : ((#j -o #h) -o ((#d -o #b) -o (#j -o #b))).\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c EVAL #d & #a VTYPE 'main' &\n" +
        "#a !(ADJUNCT>in_set) #f PRED %a & strip(%a) == 'if' &\n" +
        "#f OBJ #g SEM #h TEMP-REF #i EVAL #j\n" +
        "==> #b COND #k & #k GLUE [/P_t.[/Q_t.(P -> Q)]]  : (#h -o (#b -o #k)).\n" +
        "\n" +
        "//modification\n" +
        "#g SEM #j SIT #l & #j FPS #o CHECK '+' & #o EVENT #p &\n" +
        "#g ADJUNCT #e in_set #h OBJ #m SEM #a  & #h SEM #b SIT #c\n" +
        "==> #h GLUE [/P_<v,t>.[/Q_<s,<v,t>>.[/s_s.[/e_v.(P(e) \\& Q(s)(e))]]]] : ((#p -o #b) -o ((#l -o (#p -o #o)) -o (#l -o (#p -o #o)))) &\n" +
        " #e GLUE [/y_e.[/e_v.with(e,y)]] : (#a -o (#p -o #b)).\n" +
        "\n" +
        "//Closure\n" +
        "#b FPS #c ==> #c CLOSURE #d.\n" +
        "#b FPS #c initP #d & #c CLOSURE #e & #b SIT #f ==> #e GLUE [/P_<s,<v,t>>.[/s_s.Ee_v[P(s)(e)]]] : ((#f -o (#d -o #c)) -o (#f -o #b)).\n" +
        "#b FPS #c CLOSURE #e & #c EVENT #z & #c CHECK '+' & #b SIT #f ==> #e GLUE [/P_<s,<v,t>>.[/s_s.Ee_v[P(s)(e)]]] : ((#f -o (#z -o #c)) -o (#f -o #b)).\n" +
        "\n" +
        "\n" +
        "\n" +
        "//Rules for interpreting grammatical aspect\n" +
        "#a SEM #b VIEWPOINT #c ==>\n" +
        "#c VAR #d & #c RESTR #e &\n" +
        "#c ASP-RESTR' #f.\n" +
        "\n" +
        "\n" +
        "#a SEM #b VIEWPOINT #c A-RESTR 'ongoing' &\n" +
        "#c VAR #d & #c RESTR #e &\n" +
        "#c ASP-RESTR' #f ==>\n" +
        "#f GLUE [/s_s.[/t_s.ongoing(t,s)]] : (#d -o (#e -o #c)).\n" +
        "\n" +
        "#a SEM #b VIEWPOINT #c A-RESTR 'bounded' &\n" +
        "#c VAR #d & #c RESTR #e &\n" +
        "#c ASP-RESTR' #f ==>\n" +
        "#f GLUE [/s_s.[/t_s.bounded(t,s)]] : (#d -o (#e -o #c)).\n" +
        "\n" +
        "\n" +
        "#a SEM #b VIEWPOINT #c ASPECT 'impv' &\n" +
        "#c VAR #d & #c RESTR #e &\n" +
        "#b TEMP-REF #f &\n" +
        "#b SIT #g\n" +
        " ==>  #c GLUE [/M_<s,<s,t>>.[/P_<s,t>.[/s_s.Az_s[M(s)(z) -> P(z)]]]] : ((#d -o (#e -o #c)) -o ((#g -o #b) -o (#f -o #b))).\n" +
        "\n" +
        "#a SEM #b VIEWPOINT #c ASPECT 'prv' &\n" +
        "#c VAR #d & #c RESTR #e &\n" +
        "#b TEMP-REF #f &\n" +
        "#b SIT #g\n" +
        " ==>  #c GLUE [/M_<s,<s,t>>.[/P_<s,t>.[/s_s.Ez_s[M(s)(z) \\& P(z)]]]] : ((#d -o (#e -o #c)) -o ((#g -o #b) -o (#f -o #b))).\n" +
        "\n" +
        "#a SEM #b VIEWPOINT #c ASPECT 'undefined' &\n" +
        "#b TEMP-REF #f &\n" +
        "#b SIT #g\n" +
        " ==>  #c GLUE [/P_<s,t>.[/s_s.P(s)]] : ((#g -o #b) -o (#f -o #b)).\n" +
        "\n" +
        "//Tense values\n" +
        "\n" +
        "//TODO make so that one tense restrictor works for both relative and absolute tenses\n" +
        "\n" +
        "//Past reference\n" +
        "#a SEM #b TEMP-REF #c T-REF 'past' & #c EVAL #d & #c CHECK '-' ==>\n" +
        "#c T-REF' #e & #e GLUE [/t_s.[/t2_s.before(t,t2)]] : (#c -o (#d -o #c)).\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c T-REF 'past' & #c EVAL #d & #c CHECK '+' ==>\n" +
        "#c T-REF' #e & #e GLUE [/t_s.[/t2_s.before(t,t2)]] : (#c -o (#d -o #c)).\n" +
        "\n" +
        "//Aspectual tense\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c EVAL #d &\n" +
        "#b ASP-TENSE #e A-REF 'past' &\n" +
        " ==>\n" +
        "#e A-REF' #f & #f GLUE [/t_s.[/t2_s.before(t,t2)]] :(#e -o (#c -o #e)) .\n" +
        "\n" +
        "//Present reference\n" +
        "#a SEM #b TEMP-REF #c T-REF 'pres' & #c EVAL #d & #c CHECK '-' ==>\n" +
        "#c T-REF' #e & #e GLUE [/t_s.[/t2_s.overlap(t,t2)]] : (#c -o (#d -o #c)).\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c T-REF 'pres' & #c EVAL #d & #c CHECK '+' ==>\n" +
        "#c T-REF' #e & #e GLUE [/t_s.[/t2_s.overlap(t,t2)]] : (#c -o (#d -o #c)).\n" +
        "\n" +
        "//Non-future\n" +
        "#a SEM #b TEMP-REF #c T-REF 'non-future' & #c EVAL #d & #c CHECK '-' ==>\n" +
        "#c T-REF' #e & #e GLUE {[/t_s.[/t2_s.before(t,t2)]],[/t_s.[/t2_s.overlap(t,t2)]]} : (#c -o (#d -o #c)).\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c T-REF 'non-future' & #c EVAL #d T-REF %a ==>\n" +
        "#c T-REF' #e & #e GLUE {[/t_s.[/t2_s.before(t,t2)]],[/t_s.[/t2_s.overlap(t,t2)]]} : (#c -o (#d -o #c)).\n" +
        "\n" +
        "//Non-past\n" +
        "#a SEM #b TEMP-REF #c T-REF 'non-past' & #c EVAL #d & #c CHECK '-' ==>\n" +
        "#c T-REF' #e & #e GLUE {[/t_s.[/t2_s.after(t,t2)]],[/t_s.[/t2_s.overlap(t,t2)]]} : (#c -o (#d -o #c)).\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c T-REF 'non-past' & #c EVAL #d T-REF %a ==>\n" +
        "#c T-REF' #e & #e GLUE {[/t_s.[/t2_s.after(t,t2)]],[/t_s.[/t2_s.overlap(t,t2)]]} : (#c -o (#d -o #c)).\n" +
        "\n" +
        "//Future reference\n" +
        "#a SEM #b TEMP-REF #c T-REF 'future' & #c EVAL #d & #c CHECK '-' ==>\n" +
        "#c T-REF' #e & #e GLUE [/t_s.[/t2_s.after(t,t2)]] : (#c -o (#d -o #c)).\n" +
        "\n" +
        "#a SEM #b TEMP-REF #c T-REF 'future' & #c EVAL #d T-REF %a ==>\n" +
        "#c T-REF' #e & #e GLUE [/t_s.[/t2_s.after(t,t2)]] : (#c -o (#d -o #c)).\n" +
        "\n" +
        "\n" +
        "//absolute tense closure\n" +
        "#a SEM #b TEMP-REF #c T-REF %a & %a != 'undefined' & #c EVAL #d & #c CHECK '-'\n" +
        "==> #c GLUE [/T_<s,<s,t>>.[/P_<s,t>.[/s_s.Er_s[T(r)(s) \\& P(r)]]]] : ((#c -o (#d -o #c)) -o ((#c -o #b) -o (#d -o #b))).\n" +
        "\n" +
        "//relative tense closure\n" +
        "#a SEM #b TEMP-REF #c T-REF %a & %a != 'undefined' & #c EVAL #d T-REF %b\n" +
        "==> #c GLUE [/T_<s,<s,t>>.[/P_<s,t>.[/s_s.Er_s[T(r)(s) \\& P(r)]]]] : ((#c -o (#d -o #c)) -o ((#c -o #b) -o (#d -o #b))).\n" +
        "\n" +
        "//aspectual tense closure\n" +
        "#a SEM #b ASP-TENSE #c A-REF %a &\n" +
        "#b TEMP-REF #e &\n" +
        " %a != 'undefined'\n" +
        "==> #c GLUE [/T_<s,<s,t>>.[/P_<s,t>.[/s_s.Er_s[T(r)(s) \\& P(r)]]]] : ((#c -o (#e -o #c)) -o ((#e -o #b) -o (#e -o #b))).\n" +
        "\n" +
        "//unspec absolute closure\n" +
        "#a SEM #b TEMP-REF #c T-REF %a & %a == 'undefined' & #c EVAL #d & #c CHECK '-'\n" +
        "==> #c GLUE [/P_<s,t>.[/s_s.P(s)]] : ((#c -o #b) -o (#d -o #b)).\n" +
        "\n" +
        "//unspec relative closure\n" +
        "#a SEM #b TEMP-REF #c T-REF %a & %a == 'undefined' & #c EVAL #d T-REF %b\n" +
        "==> #c GLUE [/P_<s,t>.[/s_s.P(s)]] : ((#c -o #b) -o (#d -o #b)).\n" +
        "\n" +
        "\n" +
        "\n" +
        "//#a SEM #b TEMP-REF #c T-REF 'pres' & #c EVAL #d ==> #c GLUE [/P_<s,t>.[/s_s.Er_s[equals(r,s) \\& P(r)]]] : ((#c -o #b) -o (#d -o #b)).\n" +
        "\n" +
        "// #a SEM #b ASP-TENSE #c A-REF 'past' & #b TEMP-REF #d ==>  #c GLUE [/P_<s,t>.[/s_s.Er_s[before(r,s) \\& P(r)]]] : ((#d -o #b) -o (#d -o #b)).\n" +
        "\n" +
        "#a SEM #b ASP-TENSE #c A-REF 'undefined' & #b TEMP-REF #d ==>  #c GLUE [/P_<s,t>.[/s_s.P(s)]] : ((#d -o #b) -o (#d -o #b)).\n" +
        "\n" +
        "#a EVAL #b & #a CHECK '-' ==> #b GLUE now : #b.\n" +
        "\n"

    /*
    fetch(url).then(response => response.text())
        .then((data) => {
            rules = data;
        })

     */
    rule_editor.getDoc().setValue(rules);







</script>

</html>
<!--
    //  var sentence = prompt("Enter a sentence");
    /*
        var params =  {
            in: sentence
        }
        const url =  page + formatParams(params)
        console.log(url);
    */
    /*
      $.getJSON(url, { get_param: 'value' }, function(data) {
          $.each(data, function(index, element) {
              $('body').append($('<div>', {
                  text: element.in
              }));
          });
      });
  */
    /*
    fetch(url)
    .then(res => res.json())
    .then((out) => {
        console.log("Output: ", out);
    }).catch(err => console.error(err));
*/
    // const xhr = new XMLHttpRequest();
    /*
       xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE)
        {
         alert(xhr.response);
        } else
        {
            alert(xhr.response);
            console.log("Failed ready state" + xhr.readyState);
            alert("Request failed");
        }
        }
    */
    /*
    xhr.responseType = 'json';
    xhr.open("GET",url,true);
    xhr.onload = function() {
        var jsonResponse = xhr.response;
        console.log("This is the content of the file:" + jsonResponse.content);
    };
    xhr.send(null);
*/
    /*
    xhr.onload = function() {
        var status = xhr.status;
        if (status === 200) {
            alert(xhr.response);
        }else{
            alert(status);
        }
    };
     */
    //   xhr.send();
    //  document.write(http.responseText)
    /*
    $.getJSON("cyto.js", function (data) {
        console.log(data);
        console.log("This is a test.");
        var cy = window.cy = cytoscape({
            container: document.getElementById('cy'),
            elements: data,
            style: [ // the stylesheet for the graph
                {
                    selector: 'node[type="syntax"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'node[type="semantics"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "red white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'edge[type="edge"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: 'edge[type="proj"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'line-style': 'dashed',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: "edge[label]",
                    css: {
                        "label": "data(label)",
                        "text-rotation": "autorotate",
                        "text-margin-x": "0px",
                        "text-margin-y": "-15px"
                    }
                }
            ],
            layout: {
                name: 'breadthfirst'
                //  rows: 1
            }
        });
    });
*/
    /*
        var cy = window.cy = cytoscape({
            container: document.getElementById('cy'), // container to render in
            elements: input,
            style: [ // the stylesheet for the graph
                {
                    selector: 'node[type="syntax"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'node[type="semantics"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "red white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
                },
                {
                    selector: 'edge[type="edge"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: 'edge[type="proj"]',
                    style: {
                        'width': 3,
                        'line-color': '#ccc',
                        'line-style': 'dashed',
                        'target-arrow-color': '#ccc',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                    }
                },
                {
                    selector: "edge[label]",
                    css: {
                        "label": "data(label)",
                        "text-rotation": "autorotate",
                        "text-margin-x": "0px",
                        "text-margin-y": "-15px"
                    }
                }
            ],
            layout: {
                name: 'breadthfirst'
                //  rows: 1
            }
        });
    */
    /*
    var cy = window.cy = cytoscape({
        container: document.getElementById('cy'), // container to render in
        elements: [ // list of graph elements to start with
            { // node a
                data: {id: '1',type: "syntax"}
            },
            { // node b
                data: {id: '2',type: "syntax"}
            },
            {
                data: {id: '3',type: "syntax"}
            },
            { // edge ab
                data: {id: '12', source: '1', target: '2', label: "TENSE",type: "edge" }
            },
            { // edge ab
                data: {id: '13', source: '1', target: '3', label: "ASPECT",type: "edge"}
            },
            { // node a
                data: {id: '4',type: "semantics"}
            },
            { // node b
                data: {id: '5',type: "semantics"}
            },
            {
                data: {id: '6',type: "semantics"}
            },
            { // edge ab
                data: {id: '45', source: '4', target: '5', label: "TENSE",type: "edge"}
            },
            { // edge ab
                data: {id: '46', source: '4', target: '6', label: "ASPECT",type: "edge"}
            },
            { // edge ab
                data: {id: '14', source: '1', target: '4', label: "projection",type: "proj"}
            }
        ]
        ,
        style: [ // the stylesheet for the graph
            {
                selector: 'node[type="syntax"]',
                css: {
                    "content": "data(id)",
                    "color": "blue",
                    "text-valign": "center",
                    "text-halign": "center",
                    "height": "60px",
                    "width": "60px",
                    "background-fill": "linear-gradient",
                    "background-gradient-stop-colors": "#00FFFF white", // get data from data.color in each node
                    "background-gradient-stop-positions": "0 30 60"
                }
            },
            {
                selector: 'node[type="semantics"]',
                    css: {
                        "content": "data(id)",
                        "color": "blue",
                        "text-valign": "center",
                        "text-halign": "center",
                        "height": "60px",
                        "width": "60px",
                        "background-fill": "linear-gradient",
                        "background-gradient-stop-colors": "red white", // get data from data.color in each node
                        "background-gradient-stop-positions": "0 30 60"
                    }
            },
            {
                selector: 'edge[type="edge"]',
                style: {
                    'width': 3,
                    'line-color': '#ccc',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                }
            },
            {
                selector: 'edge[type="proj"]',
                style: {
                    'width': 3,
                    'line-color': '#ccc',
                    'line-style': 'dashed',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                }
            },
            {
                selector: "edge[label]",
                css: {
                    "label": "data(label)",
                    "text-rotation": "autorotate",
                    "text-margin-x": "0px",
                    "text-margin-y": "-15px"
                }
            }
        ],
        layout: {
            name: 'breadthfirst'
         //  rows: 1
        }
    });
     */
-->